const Handlebars = require('handlebars');

// var potionTemplate = Handlebars.compile(potionTemplate);

var fubdnvrgkbiihiegvckjdfvkkbucjgjk = [{
  "direction": null,
  "distance": null,
  "town": "guthugel",
  "story": "The carriage rattles over yet another bump in the dirt road, sending a jolt of pain through your already aching back. You could swear you’ve been on the road for years, though in reality, it’s been closer to a month. The roads, forests, and towns you’ve passed through, ferrying passengers on their journeys, have all started to blur together and you’re beginning to consider packing it all in and setting up house in whatever the next town is.\n\n“Roads were better in my day.” Mutters a voice from one of the carriage seats. “Not so many of ‘em, of course. This ‘ere was all fields.” Looking around you, you’d argue this ‘ere was still all fields.\n\nThe voice, which has been an endless feature for the past few hours, belongs to Cooper Fitzpatrick, a retired lumberjack who, along with his pet pig, has hired you to transport him to Mittelweg. Glancing up at the sun, you try to calculate how many more hours you’ll need to listen to him and the odds of you dumping him in a ditch on the way.\n\nJust as you’re fantasizing about booting the old man out of the moving carriage, salvation appears. Ahead on the road is Guthugel, a small but moderately prosperous town. Though the town itself is home to only around 900 people, it more than triples in size several times a year thanks to its highly popular seasonal markets.\n\nThe horses are in need of food and rest, and you and your friends in dire need of some recreation. Given that you’ve made good progress and are only a short distance from your final destination, you decide to spend a couple of hours enjoying the market. You part ways with your passenger and his porcine pal, agreeing to meet back at the cart later.\n\nAfter days of sleepy villages and mostly empty roads, the market is a breath of fresh air. The atmosphere is alive with excitement and the air rich with the shouts of salespeople and traders of all kinds. Tents stretch off in every direction and you quickly find yourself drawn into the throng of the crowd and to the many and varied wares on display.\n\nMost of the goods are well outside your meagre savings but, with a little haggling and lot of browsing, you eventually come away with some new gear. Among other things, Karl picks up a second dagger, Meik a waterproof cloak and a slingshot, and Mandred kits himself out with some armour and a spear.\n\nJust as you’re thinking of heading off, you’re drawn to a spectacle: an alchemist hawking his amazing and powerful strength potions. Karl immediately pegs him as a charlatan but the naive Meik can’t help himself and soon finds himself on stage giving a demonstration. After taking a sip of the potion, he is miraculously able to lift the showman’s cart. With the potion’s merits proven, the crowd rush to buy, and the party pick up a few for themselves.\n\nThe market starts to wind down and you and your companions are back on the road. The evening draws in and your destination draws near. The birdsong and the rocking of the cart lulls you into daydreams of warm beds and full stomachs.\n\n"
}, {
  "direction": ["south"],
  "distance": "1",
  "town": "mittelweg",
  "story": "You are startled from your reverie by a piercing scream from off in the woods. As the carriage comes to a stop, several more screams tear through the night. Fearing that someone is in danger, you leave the old man and the pig to guard the carriage while you head off to investigate.\n\nThe darkness in the forest is far deeper than it was on the road and you cautiously pick your way towards the sounds. After a few tense minutes, you come upon a clearing where a horrifying scene is taking place. A young couple and their infant child lie on the ground being viciously attacked by 3 beastmen. Seeing that at least one of them appears to still be alive, the party goes to their aid.\n\nThe beastmen—a large goat-headed Gor and two smaller unGors—seem surprised by your presence, rounding on you as you attack.\nMandred blasts at the Gor with his pistol, seriously injuring it. He himself is hit by a poorly thrown spear, vindicating his armour purchase Guthugel. Before Mandred can recover, Karl charges into the fray.\nOn the other side of the melee, Meik finds himself in a wrestling match with a spear-wielding unGor, grappling it to the ground. After trading blows and cuts, he wraps an arm around its neck and holds on for dear life, choking it.\nIn a frenzy, the Gor swings its mighty axe at Karl. Seeing that the end is almost upon him, Karl musters up all his strength and courage, kicking the Gor’s legs from under it. In the confusion, they both tumble to the ground.\nDespite its wounds, the Gor strikes a massive blow to Karl’s head, before being finished off by a well-aimed stab from Mandred. Seeing their ally defeated, the unGors flee into the trees.\n\nThe party reviews the carnage before them. The man and child are torn to pieces and, by now, the woman has also died. Investigating more closely, Mandred prizes a delicate comb from the Gor’s fist which you decide to take with you. Finally, Mandred cuts off the Gor’s head and Karl (with a little help) takes its axe as proof of your encounter. Wounded and exhausted, you make your way back to the carriage where you discover your brave guard, and his pig, comfortably asleep.\n\n"
}, {
  "direction": null,
  "distance": null,
  "town": "mittelweg",
  "story": "After a short and nervous drive, you arrive in Mittelweg. The hour is late and the village is mostly asleep. As you part ways with Cooper, he advises that you’ll find places to sleep in the church or the inn. Needing somewhere to stable the horses, you start with the inn but find the staff there surly and unhelpful and the fees for the night exorbitant. They suggest that if you don’t like what they’re offering you might want to check out the house of Vixea, the local whore.\n\nYou try the church but find no one home and so, irritated and out of options, you return to the inn. Mandred and Meik settle for a cold wash, a meagre meal, and the one available bed while Karl chooses to visit Vixea. There he finds a warm bath and warm food and while he also has to share a bed, he doesn’t mind as much.\n\n"
}, {
  "direction": null,
  "distance": null,
  "town": "carroburg",
  "story": "You all awaken in an Inn, hungover as all hell. You have no memory of the preceeding day. You go down stairs, take food from the kind but stern Esme (who seems to be the halfling tavern keep of the Pointed Anchor) and, after a rocky attempt at plicating an annoyed ogre, begin to recollect the previous days events.\n\nYou're in the town of Carroburg, you arrived yesterday. You all met during the afternoon, when a fight broke out in an allyway between two men (possibily a robbery), though you dont remember what they were fighting over. You all fought a fistfight with them.\n\n- Mandred was given a shinging eye by one assailant, and a sore arm by another.\n- One man was stabbed in the back by Karl\n- Another completely demolished by Meiks practiced fistfighting ability.\n- The \"leader\" escaped into an alley.\n\nThe person being robbed was extremely thankful and gave you 5 silver each for helping them, telling you to have a good night with it.\n\nYou all go to a bar and get to know each other.\n\nYou made the most of the money given as well, heading to a variety of drinking places in town and chatting to various folks while pissed. Seems a lot was happening in town, from trader disputes, to gang crimes, and nobel family differences. To name but a few of your escapades, you meet:\n- A swaying drunk with very little to say and a wide jaw\n- Meik befriends a pair of old sailors, who treat you to repeditive gossip\n- A pair of \"card sharps\" are blunted by Karl's gambling ability\n- Mandred is offered a job by the blackpikes\n\n\n"
}, {
  "direction": ["south"],
  "distance": null,
  "town": "carroburg",
  "story": "You also try to visit some very closed seedy bars and are denied and end up going to a rich mans bar (with a little of Karls way with words explaining away your shabby atire to the armed bouncers outside, with a little help from Meik). Once inside, young man puts you in touch with one Jarome von Valtbliz, who has some family trouble that he'd like disposible assistance with, and writes you a note of when and where to meet. Karl attempts to get some information out of some nearby folks (very successfully) and makes a friend or two without event cheating anyone, while Meik and Mandred get to know each other. Helpfully, the young man who introduced you also covers your drinks for the evening, preventing you from finding out if the bouncers outside know how to use their swords.\n\nYour memory then gets extremely hazy, and your exact actions are difficult to say.\n\nThe next day, after dealing with a hangover and a \"cheated\" Ogre, you head out into the town. On the way, Karl enters the The Drowned Rat in Docksward, dispite not having been invited and having stabbed one of the Pikes only the day before. Runs out being chased by several angry, tattooed thugs. Loses favorite deck of cards, but luckily not an arm.\n\nEventually you make your way to Jaromes house to find a very unpleasent man (with a taste for young house maids), though perhaps he just likes people to arrive on time to their appointments (you are at least an hour late). Arrogant and agressive and caked with makeup, he tells the aprty that he is jealious of his brother's (Lord Oscar) success, and wishes for his place at the right hand of Wulfram von Todbringer. Hes not interested in details, and just wants it done.\n\nCalling on Karl's connection from the past, you meets up with Ecchart Fuchs (borther of Karls household maid, Emilia Fuchs). He tells you some interesting info of the von Valtbliz family, including the location of the von Valtbliz Manor.\n\n"
}, {
  "direction": ["north"],
  "distance": null,
  "town": "carroburg",
  "story": "After getting to the von Valtbliz Manor, you arrive and are obviously thought to be workers or people needing jobs, and are dismissed from the front door quicky to the servents entrance. Seems you must attempt to enter the household. With some good speaking and better rolls (Meiks knowledge of fish being of great use, and buying time for Karls charm to kick in), you manage to score jobs in the von Valtbliz Manor in Darkfair.\n\nThe head of the house (the Butler) is a harried man, who says the extra assistance for the maids and cooks would be useful. Lord Oscar seems like an OK boss too, you meet him in his sitting room after dressing up ( and though Mandred \"accidentally\" shaved off his eyebrows, Lord Oscar didn't seem to mind) he approves your hiring. Karl and Mandred quickly prove their worth by materialsing 3 oaktrees worth of wood out of the thin air located around the neighbors wood pile, and Meik manages to win the cook over by showing a great keenness for fish and its acquisition. Most of the household enjoys the company of you all, dispite the missing hair above the eye on some.\n\nIt the comes out that Lord Oscar has a strange habit of running around town dressed as a peasent, as you don't need disguises to look poor, Meik lends his shoes to the lord to assist in his disguise (and bags some new shoes in the proccess). You manage find and follow the tracks of Meiks old shoes in the snow to a some sort of drinking complex (The Three Pubs.) in town, 3 differnt \"fun\" houses and split up to search.\n1. A heavy drinking place - Everyone goes into this bar, but it quickly shows to be empty of the lord.\n2. A brothel - Taken by Mandred, finds nothing but large tits and a decent deal on weirdroot.\n3. An opium den - Both Karl and Meik take this and while enjoying the fumes, find the square jaw of Lord Oscar von Valtbliz, dressed some basic peasent garb.\n\nWhile shocked to see them, Lord Oscar von Valtbliz seems to think his disguise is working and take the opertunity to ask about himself of you. Eventually Mandred joins outside and everyone heads off to a night of heavy drinking in various bars. It seems that Lord Oscar von Valtbliz is actually a pretty nice guy and you feel that maybe shaming him so his psychotic brother can control the city might be a bad idea.\n\nIts decided that Lord Oscar von Valtbliz needs to know of the issue, but believing him to be a soft touch, Karl attempt to convince the Butler to take a letter to theGraf (Wulfram von Todbringer). It seems the graf might not be the most understanding chracter, but instead you decide you may simply be able to convince Lord Oscar.\n\nThough the world was against it, fate was on the side of you (5 fate total infact) and the Lord Oscar is convined, a strong case made by Karl's undeniable charm, assisted by Meik and Mandreds helpful notes. Handing over his diamond gold hammer of sigmar necklace as proof, Lord Oscar sends you to see Jarome.\n\nJarome was not ready for this appointment but his newly hired housemaid lets you in to his darkened room. Jarome is in a terrible state, ranting and raving, and writing without ink. Its clear that his is a man deranged, and you feel better than ever about not giving keys of the city. Given his state, you insist on payment immidately, and he awards you 2 gold each. You tell him that his brother needs to be outed in public and that he should meet them at Pub 2 of the The Three Pubs tomorrow.\n\nWhile making your way back to the Manor, the village is rocked by a massive explosion. Seems a ship in the river has been attacked, but by who or what is a mystery. People run to the dock to help, you continue to the manor as you have improtant news for Lord Oscar.\n\n"
}, {
  "direction": ["east"],
  "distance": null,
  "town": "carroburg",
  "story": "The next evening, on arrival, Lord Oscar is shocked at his brothers appearance, having not seen him for 2 years dispite living in the same city. He asks the party to get the ball rolling. Jarome erupts, throwing a table over the room, implaing one of Lord Oscars guards. It seems his state of mind is as twisted as his body, with scales and claws under his makeup.\n\nWith a miraculous deflection, Karl manages to avoid being skewered by the 12cm long claw and Meiks stabs bounce off the Jarome-things scaled skin, Mandred puts his solid skills as a rough and tumble coachman to use, with a powerful handgun shot though the beasts twin shoulder, followed by a dagger though the eye and into the brain of the noble-turned-creature. Meik makes sure the beast is dead with a cut from shoulder to liver.\n\nLord Oscar is struck by the proceedings, and in a state of shock. He rewards you with a 1 gold bond to the Nuln Armory, a business concern he is involved with in Nuln. Karl smartly convinces the socked nobel that he already handed over the necklace to the Jarome, which he sadly accepts. In time, Jaromes lodging in the Docksward will be searched, hopefully it will be found there.\n\nIt also seems that the gangs were responsabile for the ship explosion, and that the detonated ship won't have anything to do with the Hooks (the ship is merely called The Hook), and is carrying linen for bandages and other medical supplies for the fight in Hochland against the beastmen. This does not bode well for the Blackpikes.\n\nYou shoot around thoughts about what you'll do now. Mandred has a cart that needs returning, perhaps you could all go together?\n\n"
}]



window.initMap = async function() {

  function name() {
    return arguments.callee.caller.name
  }


  function exportData(data, name = 'data') {
    downloadObjectAsJson(data, "WFRP-map-" + name)
  }



  function titleCase(str) {
    return str.toLowerCase().replace(/\b(\w)/g, s => s.toUpperCase());
  }


  function debounce(func, timeout = 300) {
    let timer;
    return (...args) => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        func.apply(this, args);
      }, timeout);
    };
  }

  // load params
  var rawParams = new URLSearchParams(window.location.search)
  var params = Object.fromEntries(
    rawParams
  );



  const map = new google.maps.Map(document.getElementById("map"), {
    center: {
      // altdorf
      lat: 31.874268441160677,
      lng: -16.277407946030955
    },
    zoom: 6,
    streetViewControl: false,
    mapTypeControlOptions: {
      mapTypeIds: ["WFRP"],
    },
    restriction: {
      latLngBounds: {
        north: 80,
        south: -80,
        west: -300,
        east: 300,
      },
    },

    gestureHandling: 'greedy'
  });



  const mapOptions = {
    getTileUrl: function(coord, zoom) {
      const normalizedCoord = getNormalizedCoord(coord, zoom);

      if (!normalizedCoord) {
        return "";
      }
      const bound = Math.pow(2, zoom);
      // log("old",`http://www.gitzmansgallery.com/tiles/${zoom}_${normalizedCoord.x}_${(normalizedCoord.y-1)}.jpg`);
      return (
        // `${params.tileURL}/tiles/${zoom}_${normalizedCoord.x}_${(normalizedCoord.y)}.jpg`
        // `http://${params.tileURL}/tiles/${zoom}_${normalizedCoord.x}_${(normalizedCoord.y)}.jpg`

        `./map/${zoom}/${zoom}_${normalizedCoord.x}_${(normalizedCoord.y)}.jpg`

      );
    },
    tileSize: new google.maps.Size(256, 256),
    maxZoom: 7,
    minZoom: 3,
    // radius: 10000,
    name: "WFRP",
  }

  const wfrpMapType = new google.maps.ImageMapType(mapOptions);
  map.mapTypes.set("WFRP", wfrpMapType);
  map.setMapTypeId("WFRP");



  // Normalizes the coords that tiles repeat across the x axis (horizontally)
  // like the standard Google map tiles.
  function getNormalizedCoord(coord, zoom) {
    const y = coord.y;
    let x = coord.x;
    // tile range in one direction range is dependent on zoom level
    // 0 = 1 tile, 1 = 2 tiles, 2 = 4 tiles, 3 = 8 tiles, etc
    const tileRange = 1 << zoom;

    // don't repeat across y-axis (vertically)
    if (y < 0 || y >= tileRange) {
      return null;
    }

    // repeat across x-axis
    if (x < 0 || x >= tileRange) {
      x = ((x % tileRange) + tileRange) % tileRange;
    }
    return {
      x: x,
      y: y
    };
  }








  /*

  control zoom
    save zoom
    load from file

  control view position
    save positon
    load from file

  markers
    place
    comment on
    delete
    load from file
    save

  path
    place
    modify
    delete
    load from file
    save

  optional extras
    layers
    states
    fow


  */


  var randomString = function() {
    var str = Math.random().toString(36).substring(7)
    return str
  }


  map.handlers = {}

  // var handlers = map.handlers
  map.handlers.defaults = {
    lineStyles: {
      strokeColor: 'blue',
      strokeOpacity: 0,

      icons: [{
        icon: {
          path: "M 0,-1 0,1",
          strokeOpacity: 1,
          scale: 4,
        },
        offset: "0",
        repeat: "20px",
      }, ],
    }
  }

  var memoryhandler = {
    init: function(map) {
      this.map = map
      return this
    },
    save: (name, value) => localStorage.setItem(name, value),
    load: (name) => {
      var rawMemory = localStorage.getItem(name)
      try {
        var m = JSON.parse(rawMemory);
        return m
      } catch (e) {
        return undefined
      }
    },
    import: function(memoryArray) {
      memoryArray = JSON.parse(memoryArray)
      console.log("import", memoryArray);
      for (var memory of memoryArray) {
        if (!memory.memory) continue;
        console.log("importing", memory.name);
        this.save(memory.name, JSON.stringify(memory.memory))

        if (this.map.handlers[memory.name] && this.map.handlers[memory.name].loadFromMemory) this.map.handlers[memory.name].loadFromMemory()

      }
    },
    export: function(map = map) {
      console.log("export");
      var exp = []
      for (var [name, handlerValue] of Object.entries(map.handlers)) {
        var memory = this.load(name)
        if (!memory) continue;
        exp.push({
          name,
          memory
        })
      }
      return exp
    },
  }

  map.handlers.memory = memoryhandler.init(map)


  map.handlers.settings = map.handlers.memory.load("settings")


  map.handlers.view = {
    defaults: {
      maxViewHistory: 20,

    },
    viewHistory: [],
    init: function(map) {
      console.info("view", name());
      map.addListener('zoom_changed', () => this.updateView());
      map.addListener('center_changed', () => this.updateView());
      this.map = map
      //
      return this
    },
    setView: function(data) {
      console.info(name());
      if (!data || !data.position || !data.zoom) {
        console.warn("must supply both data.position and data.zoom", data);
        return
      }
      this.map.setCenter(data.position);
      this.map.setZoom(Number(data.zoom));
      this.updateView()
    },

    loadFromMemory: function() {
      console.info(name());
      var view = this.map.handlers.memory.load("view");
      this.setView(view)
      return view

    },
    updateView: function() {
      var zoom = this.map.getZoom()
      var position = this.map.getCenter().toJSON()
      // console.info(name(), position, zoom);
      var view = {
        zoom,
        position
      }
      this.map.handlers.memory.save("view", JSON.stringify(view))
      // this.map.handlers.memory.save("center", JSON.stringify(position))
      // this.map.handlers.memory.save("zoom", zoom)
      // update histroy
      this.viewHistory.push({
        zoom,
        position
      })
      if (this.viewHistory.length > this.defaults.maxViewHistory) {
        this.viewHistory = this.viewHistory.slice(-this.defaults.maxViewHistory)
      }
    },
  }

  var view = map.handlers.view.init(map)
  view.loadFromMemory()





  map.handlers.markers = {
    markers: [],
    // to prevent save flooding
    init: function(map) {

      console.info("markers", name());
      this.map = map
      this.cluster = new MarkerClusterer(this.map, this.markers, {
        imagePath: "https://unpkg.com/@googlemaps/markerclustererplus@1.0.3/images/m",
        maxZoom: mapOptions.maxZoom - 1,
      });

      // added saving behind this shock adsorber to prevent flooding
      this.saveMarkersToMemory = debounce(() => {
        // compare old and new  mem to make sure we're not saving something uselessly
        var oldMem = this.map.handlers.memory.load("markers")
        var mem = this.markers.map(marker => marker.export())
          .filter(m => !m.data.tags.includes("temp"))
        if (JSON.stringify(oldMem) != JSON.stringify(mem)) {
          this.cluster.clearMarkers()
          console.log("saved", mem.length);
          this.map.handlers.memory.save("markers", JSON.stringify(mem))
          this.cluster.addMarkers(this.markers)

        }
      }, 500)

      return this
    },

    loadFromMemory: function() {
      var mem = this.map.handlers.memory.load("markers")
      console.log(name(), mem);
      if (mem && mem.length > 0) mem
        .map(marker => this.createMarker({
          ...marker,
          imported: true
        }))
      this.cluster.addMarkers(this.markers)
    },
    deleteMarker: function(marker) {
      console.info(name());

      var target = this.markers.find(m => m === marker || (JSON.stringify(m.export()) == JSON.stringify(marker.export())) || m.data.id == marker.data.id)
      this.markers = this.markers
        .filter(m => target != m)
      target.setMap(null)
      this.saveMarkersToMemory()
      return this.markers
    },
    deleteAllMarkers: function() {
      return this.markers
        .map(marker => this.deleteMarker(marker))
    },

    createMarker: function(info) {
      // console.info(name());
      if (!info.position) return



      // make marker
      var marker = new google.maps.Marker({
        data: {
          tags: []
        },
        ...info,
        position: info.position,
        map: this.map,

        export: function() {
          return {
            position: this.getPosition().toJSON(),
            data: this.data,
          }
        },
      });

      if (!marker.data.id) marker.data.id = randomString()


      // set up the needed events to make markers usable
      google.maps.event.addListener(marker, "contextmenu", (e) => {
        if (!marker.getDraggable()) return;
        if (e.domEvent.altKey) this.deleteMarker(marker)

      })

      google.maps.event.addListener(marker, "mouseup", (e) => {
        this.saveMarkersToMemory()
      })

      this.markers.push(marker)
      this.saveMarkersToMemory()
      return marker
    },


  }




  var markers = map.handlers.markers.init(map)
  markers.loadFromMemory()
  // markers.markers.map(m => m.setDraggable(true))
  // markers.deleteAllMarkers()
  //
  // Array.from(new Array(10))
  //   .forEach((e, i) => markers.createMarker({
  //     position: {
  //       lng: 1 * (i / 1),
  //       lat: 1 * (i / 1)
  //     },
  //     data: {
  //       tags: ["temp"]
  //     }
  //   }))



  map.handlers.lines = {
    lines: [],
    init: function(map) {

      console.info("lines", name());
      this.map = map


      return this
    },

    saveLinesToMemory: function() {
      var mem = this.lines.map(line => line.export()).filter(r => r)
        .filter(m => !m.data.tags.includes("temp"))
      console.info(name(), mem.length);
      this.map.handlers.memory.save("lines", JSON.stringify(mem))
    },

    loadFromMemory: function() {
      var mem = this.map.handlers.memory.load("lines")
      console.info(name(), mem);
      if (mem && mem.length > 0) mem
        .map(line => this.createLine({
          ...line,
          imported: true
        }))
      // .map(line => this.deleteLine(line))
    },
    deleteLine: function(line) {
      console.info(name());
      var target = this.lines.find(m => m === line || (JSON.stringify(m.export()) == JSON.stringify(line.export())) || m.data.id == line.data.id)
      this.lines = this.lines
        .filter(l => target != l)
      target.setMap(null)
      this.saveLinesToMemory()
      return this.lines
    },
    deleteAllLines: function() {
      return this.lines
        .map(line => this.deleteLine(line))
    },
    createLine: function(info) {
      console.info(name(), info);
      if (!info.path) return

      // make line
      var line = new google.maps.Polyline({
        data: info.data || {
          id: randomString(),
          tags: []
        },
        ...info,
        path: info.path,
        map: this.map,

        export: function() {
          if (this.getPath().getArray().length < 2) return undefined
          return {
            path: this.getPath().getArray(),
            data: this.data,
            strokeColor: this.strokeColor,
            strokeOpacity: this.strokeOpacity,
            icons: this.icons,
          }
        },
      });



      // set up the needed events to make lines usable
      google.maps.event.addListener(line, "contextmenu", (e) => {
        if (e.vertex == undefined) return;
        if (!line.editable) return;
        var path = line.getPath();
        path.removeAt(e.vertex);
        this.saveLinesToMemory()
        if (path.length < 2) this.deleteLine(line)
        if (e.domEvent.altKey) this.deleteLine(line)

      })

      google.maps.event.addListener(line, "mouseup", (e) => {
        this.saveLinesToMemory()
      })

      this.lines.push(line)
      this.saveLinesToMemory()





      return line
    },
  }


  var lines = map.handlers.lines.init(map)
  lines.loadFromMemory()
  // lines.deleteAllLines()




  lines.lines
    .map(line => line.setEditable(true))





  map.handlers.locationNames = {
    init: async function(map, data) {

      console.info("locationNames", name());
      this.map = map
      this.mapFile = await fetch(data.url)
        .then(r => r.json())
      this.mapFileCorners = data.mapFileCorners

      this.indexLocation = this.mapFile[0]
      this.locations = this.mapFile
        .filter((a, i) => i != 0)
        // clean the junk  out
        .filter(a => a.description.length > 2)
      return this
    },
    diagMode: function() {
      this.map.handlers.lines.createLine({
        path: [{
            lng: 0,
            lat: 80
          }, {
            lng: 0,
            lat: 0
          },
          {
            lng: 0,
            lat: -80
          }
        ],
        tags: ["temp"],
      })

      this.map.handlers.lines.createLine({
        path: [{
            lng: 180,
            lat: 0
          }, {
            lng: 0,
            lat: 0
          },
          {
            lng: -180,
            lat: 0
          }
        ],
        tags: ["temp"],
      })



      this.fastMarker(this.mapFileCorners.getNorthWest, "this.mapFileCorners.getNorthWest")
      this.fastMarker(this.mapFileCorners.getSouthEast, "this.mapFileCorners.getSouthEast")


    },
    findLocationCenter: function(location) {

      var center = function(arr) {
        var x = arr.map(function(a) {
          return a[0]
        });
        var y = arr.map(function(a) {
          return a[1]
        });
        var minX = Math.min.apply(null, x);
        var maxX = Math.max.apply(null, x);
        var minY = Math.min.apply(null, y);
        var maxY = Math.max.apply(null, y);
        return [(minX + maxX) / 2, (minY + maxY) / 2];
      }


      if (!location) return

      var l = center(location.boundingPoly.vertices.map(v => [v.x, v.y]))

      // console.log("parseLocationNames", location.description);

      return {
        x: l[0],
        y: l[1],
      }

    },
    findLocationByName: function(name) {
      name = name.toLowerCase()
      var raw = this.findLocationCenter(this.locations.find(l => l.description.toLowerCase().includes(name)))
      if (!raw) {
        console.log("location", name, "not found");
        return
      }




      var x = raw.x
      var y = raw.y
      var XMax = this.indexLocation.boundingPoly.vertices[2].x
      var YMax = this.indexLocation.boundingPoly.vertices[2].y



      // console.log(x, XMax, x / XMax, "%");
      // console.log(y, YMax, y / YMax, "%");

      var rawMapToMapBounds = this.mapFileCorners

      var lngDistance = Math.abs(rawMapToMapBounds.getNorthWest.lng) + Math.abs(rawMapToMapBounds.getSouthEast.lng)
      var latDistance = Math.abs(rawMapToMapBounds.getNorthWest.lat) + Math.abs(rawMapToMapBounds.getSouthEast.lat)
      // console.log(lngDistance);
      // console.log(latDistance);



      var mappedXToLngPercent = (x / XMax) * lngDistance
      var mappedYToLatPercent = (y / YMax) * latDistance

      // console.log("mappedXToLngPercent", mappedXToLngPercent)
      // console.log("mappedYToLatPercent", mappedYToLatPercent)




      // console.log(name," rawMapToMapBounds.getNorthWest.lng + mappedXToLngPercent", mappedXToLngPercent);
      console.log(name, mappedYToLatPercent, (latDistance / 2), ((latDistance / 2) - (mappedYToLatPercent)), (y / YMax));




      var calc = {
        lng: rawMapToMapBounds.getNorthWest.lng + (mappedXToLngPercent - 6.9),
        lat: rawMapToMapBounds.getNorthWest.lat + (((-mappedYToLatPercent + 7) - ((latDistance / 2) - (mappedYToLatPercent)) / 5)),
        // lat: rawMapToMapBounds.getNorthWest.lat + (((-mappedYToLatPercent + 7) - ((latDistance / 2) - (mappedYToLatPercent)) / 5)),
        // lat: rawMapToMapBounds.getNorthWest.lat + (-mappedYToLatPercent),
      }

      // console.log("calc", calc);


      // fastMarker(calc, name)

      return calc



      // rawMapToMapBounds.getNorthWest

    },

    fastMarker: function(pos, title) {
      return this.map.handlers.markers.createMarker({
        position: pos,
        data: {
          tags: ["temp"],
          title: title
        }
      })
    },
    placeMarkerAtTown: function(name) {

      var pos = this.findLocationByName(name)
      if (!pos) {
        console.warn(name, "not found");
      }
      this.fastMarker(pos, name)
    }
  }


  var locationNames = await map.handlers.locationNames.init(map, {
    url: './map/mapreader/foundImages_5120_empire_bw3.json',
    mapFileCorners: {
      getNorthWest: {
        lat: 51.61577247781892,
        lng: -24.50441987718352
      },
      getSouthEast: {
        lat: 4.244208080077743,
        lng: 31.7345937946915
      }


    }
  }, )



  // map.handlers.locationNames = {
  //   init: async function(map, data) {
  //
  //     console.info("locationNames", name());
  //     this.map = map
  //     this.mapFile = await fetch(data.url)
  //       .then(r => r.json())
  //     this.mapFileCorners = data.mapFileCorners
  //
  //     this.indexLocation = this.mapFile[0]
  //     this.locations = this.mapFile
  //       .filter((a, i) => i != 0)
  //       // clean the junk  out
  //       .filter(a => a.description.length > 2)
  //     return this
  //   },
  // }



  class SettingHandler {
    // this is a way of making the settings easier to set
    // when innitalised, it returns a setter/getter that will run the given function
    constructor(parent, values) {
      this.action = values.action
      this.inital = values.inital
      this.ob = {
        ...values,
        // get the vvalue
        get value() {
          return this.inital
        },
        // set the vvalue and also run the function
        set value(val) {
          if (values.action) values.action(val, parent)
          this.inital = val
          return val
        }
      }
      this.ob.value = this.inital
      return this.ob
    }
  }




  // var x = JSON.stringify(map.handlers.memory.export(map))
  // console.log(x);


  map.handlers.controls = {
    settings: {
      // each setting has an innital value and a function it runs when its edited
      markerEdit: {
        title: "Dragable markers",
        inital: true,
        type: "checkbox",
        action: (value, parent) => parent.markers.markers.map(m => m.setDraggable(value))
      },
      lineEdit: {
        title: "Editable lines",
        inital: false,
        type: "checkbox",
        action: (value, parent) => parent.lines.lines.map(line => line.setEditable(value))
      },
      autoSelect: {
        title: "Auto select new marker",
        inital: true,
        type: "checkbox",
        action: (value, parent) => {}
      },
      tags: {
        title: "Tags",
        inital: ["manual"],
        type: "dropdown",
        action: (value, parent) => console.log("its happenung,tags", value, parent)
      },
      import: {
        title: "Import map data",
        inital: false,
        type: "button",
        action: async (value, parent) => {
          if (!value) return

          // new parent.Swal()
          uploadFileScreen()
            .then(data => parent.map.handlers.memory.import(data))
        }
      },
      export: {
        title: "Export map data",
        inital: false,
        type: "button",
        action: (value, parent) => {
          if (!value) return

          downloadObjectAsJson(parent.map.handlers.memory.export(map), "wfrp-map-export")
        }
      },
    },
    init: async function(map, markers, lines) {
      this.Swal = require('sweetalert2')

      console.info("controls", name());
      this.map = map
      this.controlDIV = document.querySelector("#controls")
      this.markers = markers
      this.lines = lines

      // iterate over the settings and make them into settings handllers
      for (var [key, value] of Object.entries(this.settings)) {
        this.settings[key] = new SettingHandler(this, value)
      }


      this.drawingManager = await new google.maps.drawing.DrawingManager({
        drawingMode: null,
        drawingControl: true,
        drawingControlOptions: {
          position: google.maps.ControlPosition.TOP_CENTER,
          drawingModes: [
            google.maps.drawing.OverlayType.MARKER,
            // google.maps.drawing.OverlayType.CIRCLE,
            // google.maps.drawing.OverlayType.POLYGON,
            google.maps.drawing.OverlayType.POLYLINE,
            google.maps.drawing.OverlayType.RECTANGLE,
          ],
        },
        markerOptions: {
          icon: "https://developers.google.com/maps/documentation/javascript/examples/full/images/beachflag.png",
        },
        // polylineOptions: this.map.handlers.defaults.lineStyles,
      });

      this.drawingManager.setMap(map);
      await this.loadNav()

      for (let [n, obj] of Object.entries(this.menus)) {
        console.log("activating sidebar menu controller:", n);
        await obj.init(this)
      }
      this.addListeners()




      return await this
    },
    addListeners: function() {

      google.maps.event.addListener(this.drawingManager, 'markercomplete', (marker) => {
        // make a marker
        console.log(this.settings.tags.value);
        var m = this.markers.createMarker({
          position: marker.position,
          draggable: this.settings.markerEdit.value,
          data: {
            tags: [...this.settings.tags.value]
          }

        });


        // delete the one placed bby the controller
        marker.setMap(null)

        if (!this.settings.autoSelect.value) return
        this.menus.hand.selectMarker(m)

      });

      google.maps.event.addListener(this.drawingManager, 'polylinecomplete', (line) => {
        // create a line
        this.lines.createLine({
          path: line.getPath().getArray(),
          ...this.map.handlers.defaults.lineStyles
        })
        // delete the one placed bby the controller
        line.setMap(null)

      });

      google.maps.event.addListener(this.drawingManager, "drawingmode_changed", (event) => {
        console.log("drawing mode changed:" + this.drawingManager.getDrawingMode());
      })

    },
    loadNav: async function() {
      this.controlDIV.innerHTML = "Loading..."

      await fetch("./templates/base.hbs")
        .then(r => r.text())
        .then(r => Handlebars.compile(r))
        .then(r => r({
          setting: "ok"
        }))
        .then(r => this.controlDIV.innerHTML = r)

      return this.controlDIV

    },
    menus: {
      hand: {
        inputboxSave: async function(event, marker) {
          if (event.target.dataset.id != marker.data.id) throw "how did we not match?"
          marker.data[event.target.name] = event.target.value
          this.parent.markers.saveMarkersToMemory()
        },
        deselectMarkers: async function() {
          this.parent.markers.markers.forEach(mm => mm.setAnimation(null))
          this.parent.controlDIV.querySelector(".content").innerHTML = ""
          this.drawControls()
          this.dehoverMarkers()

        },
        selectMarker: async function(marker) {
          // deselect all
          this.deselectMarkers()
          // set animation
          marker.setAnimation(google.maps.Animation.BOUNCE);

          var container = this.parent.controlDIV.querySelector(".content")
          container.innerHTML = this.markerSelectionTemplate(marker)
          var inputs = [...container.querySelectorAll(".input")]
          // add event listeners to each  of the inputs
          inputs.forEach(input => input.addEventListener('keyup', e => this.inputboxSave(e, marker)))
          inputs[0].select()

        },
        dehoverMarkers: async function() {
          this.parent.markers.markers.forEach(mm => {
            if (!mm.infowindow) return
            mm.infowindow.close()
            mm.infowindow = undefined
          })

        },
        hoverMarker: async function(marker) {
          this.dehoverMarkers()
          var content = this.markerHoverTemplate(marker)
          if (!content || content == "") return
          marker.infowindow = new google.maps.InfoWindow({
            content
          });
          marker.infowindow.open(this.parent.map, marker)
        },
        drawControls: async function() {
          // if (!parent.map.handlers.defaults.enableHandControls) return
          var content = this.parent.controlDIV.querySelector(".content")


          content.innerHTML = this.basicControlTemplate(this.parent)
          for (var [key, value] of Object.entries(this.parent.settings)) {
            var inp = content.querySelector(`input[name="${key}"]`)

            if (value.type == "button") inp.onclick = (e) => this.parent.settings[e.target.name].value = true
            inp.onchange = (e) => this.parent.settings[e.target.name].value = e.target.checked
          }
        },
        init: async function(parent) {
          this.parent = parent


          // get the templates
          this.markerSelectionTemplate = await fetch("./templates/markerSelection.hbs")
            .then(r => r.text())
            .then(r => Handlebars.compile(r))

          this.markerHoverTemplate = await fetch("./templates/markerHover.hbs")
            .then(r => r.text())
            .then(r => Handlebars.compile(r))

          this.basicControlTemplate = await fetch("./templates/handControls.hbs")
            .then(r => r.text())
            .then(r => Handlebars.compile(r))



          this.handMarkerListeners = []

          google.maps.event.addListener(this.parent.drawingManager, "drawingmode_changed", (event) => {
            if (this.parent.drawingManager.getDrawingMode()) {
              // if we're not in hand mode anymore, remove the liseners
              console.info("removing listeners");
              this.handMarkerListeners.forEach(l => google.maps.event.removeListener(l))
              return
            }

            console.info("activating the hand", this.parent.markers.markers);

            this.parent.markers.markers.forEach(marker => {
              console.log("adding listener for", marker.data.id);
              //add listeners, when activated, add this markers details to the ui
              var t = marker.addListener("mouseup", (e) => this.selectMarker(marker));
              marker.addListener("mouseover", (e) => this.hoverMarker(marker));
              // marker.addListener("mouseout", (e) => this.dehoverMarkers());


              this.handMarkerListeners.push(t)

            })
            google.maps.event.addListener(this.parent.map, "contextmenu", (event) => {
              this.dehoverMarkers()
              this.deselectMarkers()
            });

            this.drawControls()


          })

          // set to hand initally
          parent.drawingManager.setDrawingMode(null)

        },

      },
      /*

      hand:
      if read only:
        show info of POI when they are "selected"
        show hovers with breif desc
        all items static
      if edit mode:
        show hovers with breif desc
        show info of POI when they are "selected", allow edits
        allow movement, deletes of all items

      marker:
      does not show in read only
      select icon (optional)

      line:
      does not show in read only
      select line colour
      select line dots



      types of menu:
      selection menu of what kind of marker to place
      selection menu of what kind of line to place

      placing a point of interest that does not need a lot of text
      hover info
      placing a campaign champter that needs a lot of text

      */


      searchbar: {
        init: async function(parent) {
          this.parent = parent


          this.searchContainer = document.querySelector("#searchBar")
          this.locations = this.parent.map.handlers.locationNames.locations
          this.locationNamesObject = this.parent.map.handlers.locationNames
          // perhaps cleaan the names  at this point

          // get the templates
          this.searchBarTemplate = await fetch("./templates/searchbar.hbs")
            .then(r => r.text())
            .then(r => Handlebars.compile(r))

          this.searchContainer.innerHTML = this.searchBarTemplate(this.locations)
          var searchBar = this.buildSearchBox()

          return this

        },

        buildSearchBox: function() {

          return new SlimSelect({
            select: this.searchContainer.querySelector("select"),
            placeholder: "What will you add to this potion?",
            // limit: 2,
            data: this.locations.map(l => ({
              text: l.description
            })),
            placeholder: 'Placeholder Text Here',
            closeOnSelect: true,

            closeOnSelect: true,
            onChange: async info => {

              console.time("search");

              var loc = this.locationNamesObject.findLocationByName(info.value)
              if (!loc) return
              loc = new google.maps.LatLng(loc);
              console.time("panTo");
              await this.parent.map.panTo(loc)
              console.timeEnd("panTo");
              console.time("setZoom");
              await this.parent.map.setZoom(7)
              console.timeEnd("setZoom");


              var highlighter = new google.maps.Circle({
                strokeOpacity: 0,
                fillColor: "#FF0000",
                fillOpacity: 0.35,
                map: this.parent.map,
                center: loc,
                radius: 200000,
              })
              console.timeEnd("search");



              var fadeoutTime = 2 //seconds
              var fadeOutUpdateFreq = 50 //ms
              var fadePerTick = (highlighter.fillOpacity / (fadeoutTime * fadeOutUpdateFreq))


              var interval = setInterval(function() {
                if (highlighter.fillOpacity <= 0) {
                  clearInterval(interval);
                  highlighter.setMap(null);
                  console.log("deleted");
                }
                highlighter.setOptions({
                  fillOpacity: highlighter.fillOpacity - fadePerTick
                });

              }, fadeOutUpdateFreq);





            }
          });
        }


      },

    }
  }


  var drawController = await map.handlers.controls.init(map, markers, lines)



  var mapLocationDrawer = {


    init: async function(drawingManager) {
      class USGSOverlay extends google.maps.OverlayView {
        constructor(bounds, image) {
          super();
          // Initialize all properties.
          this.bounds_ = bounds;
          this.image_ = image;
          // Define a property to hold the image's div. We'll
          // actually create this div upon receipt of the onAdd()
          // method so we'll leave it null for now.
          this.div_ = null;
        }
        updateBounds(bounds) {
          this.bounds_ = bounds
          this.draw()
        }
        /**
         * onAdd is called when the map's panes are ready and the overlay has been
         * added to the map.
         */
        onAdd() {
          this.div_ = document.createElement("div");
          this.div_.style.borderStyle = "none";
          this.div_.style.borderWidth = "0px";
          this.div_.style.position = "absolute";
          // Create the img element and attach it to the div.
          const img = document.createElement("img");
          img.src = this.image_;
          img.style.width = "100%";
          img.style.height = "100%";
          img.style.position = "absolute";
          img.style.opacity = 0.5;


          this.div_.appendChild(img);
          // Add the element to the "overlayLayer" pane.
          const panes = this.getPanes();
          panes.overlayLayer.appendChild(this.div_);
        }
        draw() {
          // We use the south-west and north-east
          // coordinates of the overlay to peg it to the correct position and size.
          // To do this, we need to retrieve the projection from the overlay.
          const overlayProjection = this.getProjection();
          // Retrieve the south-west and north-east coordinates of this overlay
          // in LatLngs and convert them to pixel coordinates.
          // We'll use these coordinates to resize the div.
          const sw = overlayProjection.fromLatLngToDivPixel(
            this.bounds_.getSouthEast()
          );
          const ne = overlayProjection.fromLatLngToDivPixel(
            this.bounds_.getNorthWest()
          );

          // Resize the image's div to fit the indicated dimensions.
          if (this.div_) {
            this.div_.style.left = sw.x + "px";
            this.div_.style.top = ne.y + "px";
            this.div_.style.width = ne.x - sw.x + "px";
            this.div_.style.height = sw.y - ne.y + "px";
          }
        }
        /**
         * The onRemove() method will be called automatically from the API if
         * we ever set the overlay's map property to 'null'.
         */
        onRemove() {
          if (this.div_) {
            this.div_.parentNode.removeChild(this.div_);
            this.div_ = null;
          }
        }
      }

      google.maps.event.addListener(drawingManager, 'rectanglecomplete', (rectangle) => {
        console.log(rectangle);
        // rectangle.draggable
        // editable: true
        // rectangle.setDraggable(true)
        rectangle.setEditable(true)
        overlay = new USGSOverlay(rectangle.getBounds(), "/map/mapreader/test_images/5120_empire_bw3.png", map);
        overlay.setMap(map);


        google.maps.event.addListener(rectangle, 'bounds_changed', () => {
          overlay.updateBounds(rectangle.getBounds(rectangle))

          // NW coordinates - (x1, y1)
          // SE coordinates - (x2, y2)
          // NE coordinates - (x2, y1)
          // SW coordinates - (x1, y2)

          console.log({
            getNorthWest: rectangle.getBounds().getNorthWest().toJSON(),
            getSouthEast: rectangle.getBounds().getSouthEast().toJSON(),
          });
        });


      });

    }
  }

  // mapLocationDrawer.init(drawController.drawingManager)





  var smartImportHandler = {
    init: async function(map, locationNames, link, options = {}) {

      this.settings = {
        distanceMultiplier: 0.3,
        defaultDistance: 1,
        directions: [
          ["north", {
            lng: 0,
            lat: 1
          }],
          ["south", {
            lng: 0,
            lat: -1
          }],
          ["east", {
            lng: 1,
            lat: 0
          }],
          ["west", {
            lng: -1,
            lat: 0
          }],
        ]
      }

      this.locationNames = locationNames
      this.link = link
      this.map = map

      Object.entries(options).map(option => this[option[0]] = option[1])



      this.story = await this.getStory()
      var extractedLocations = await this.extractLocations()
      var POIs = await this.generatePOIs(extractedLocations)
      this.placeMarkers(POIs)

      if (this.enableLine) {
        this.map.handlers.lines.createLine({
          path: POIs.map(p => p.pos),
          ...this.map.handlers.defaults.lineStyles,
          strokeColor:"orange",
        })
      }

      return this
    },
    placeMarkers: async function(pois) {
      console.info(name(), pois);
      var count = 0

      for (var location of pois) {
        count += 1

        await this.map.handlers.markers.createMarker({
          position: location.pos,
          data: {
            title: `${location.direction && location.direction.join("")||""} ${titleCase(location.town)}: ${count}`,
            description: location.story,
            tags: ["temp"],
          }
        })
      }
      console.log("markers placed");
    },
    getStory: async function() {
      var repo = await fetch(`https://api.github.com/repos/${this.link}/git/trees/master`)
        .then(r => r.json())

console.debug(repo);

      var urls = repo.tree.map(r => r.url)
      
      var files = urls.map(u => fetch(u, {
        headers: {
          "Accept": "application/vnd.github.v3.raw"
        }
      }).then(r => r.text())).reverse()

      return await Promise.all(files)
    },
    generatePOIs: async function(locations) {


      var processDirection = (location) => {
        for (var dir of location.direction) {
          dir = this.settings.directions.find(d => d[0] == dir)
          location.pos.lng += dir[1].lng * location.distance * this.settings.distanceMultiplier
          location.pos.lat += dir[1].lat * location.distance * this.settings.distanceMultiplier

        }
        return location.pos

      }

      var points = []
      for (var location of locations) {
        // get the location of the town
        location.pos = locationNames.findLocationByName(location.town)
        // if it has no distance, set it as the default
        if (!location.distance) location.distance = this.settings.defaultDistance
        // if it has a direction, add each direction to the location, clamping to distance
        if (location.direction) location.pos = processDirection(location)
        // return POI map




        points.push(location)

      }
      return points

    },
    extractLocations: async function() {

      // join the whole story together
      var story = this.story.reverse().join("\n")

      var chapterRegex = /\# Location: (.*?)(?=#)/gis;
      // match each chapter based on the above regex
      var chapter = [...story.matchAll(chapterRegex)]

      var locationRegex = /Location:.*?\n/gi

      var extractedLocations = []

      for (var storySection of chapter) {
        // just in case 1 location fails, just skip it and keep going
        try {

          // get the location from the chapter
          var location = storySection[0].match(locationRegex)[0]
          // make the story by taking the chapter and removing the location
          var story = storySection[0].replace("# " + location, "")

          location = location.toLowerCase()
          // get the direction if any
          var dirRegex = /\b(?:north|south)(?:\h*(?:east|west))?\b|\b(?:east|west)\b/gi
          var direction = location.match(dirRegex)
          // get the distance if any
          var disRegex = /\b(\d+).?(\d*)\s*(?=(mile|miles|km|kms))\b/gi
          var distance = location.match(disRegex) && location.match(disRegex)[0].trim()
          // get the name of the town
          // needs to be trimmed
          // also needs two different kind in case its just a town name with nothing else
          var town = direction && distance && location.match(/\b(?<=(of))\s+([a-zA-Z]*)/gi)[0].trim() || location.replace(direction, "").replace(distance, "").replace("location:", "").trim()

          // put it together
          var parsedLocation = {
            direction,
            distance,
            town,
            story
          }
          // and push it
          extractedLocations.push(parsedLocation)

        } catch (e) {
          console.error(location, e);
          continue
        }


      }
      return extractedLocations

    },





  }

  smartImportHandler.init(map, locationNames, params.link, {
    enableLine: true
  })


  // locationNames.diagMode()
  // locationNames.placeMarkerAtTown("altdorf")
  // locationNames.placeMarkerAtTown("mittelweg")
  // locationNames.placeMarkerAtTown("talabheim")
  // locationNames.placeMarkerAtTown("carroburg")
  // locationNames.placeMarkerAtTown("bokel")
  // locationNames.placeMarkerAtTown("akendorf")
  // locationNames.placeMarkerAtTown("sava")
  // locationNames.placeMarkerAtTown("munzig")
  // locationNames.placeMarkerAtTown("kell")
  // locationNames.placeMarkerAtTown("purgg")
  // locationNames.placeMarkerAtTown("raddis")
  // locationNames.placeMarkerAtTown("bernloch")
  // locationNames.placeMarkerAtTown("ballenhof")
  // locationNames.placeMarkerAtTown("russbach")
  // locationNames.placeMarkerAtTown("zundap")
  // locationNames.placeMarkerAtTown("kurst")





  return
  return



  //

  //

  //

  //

  //

  //

  //

  //

  //

  //


  var states = await fetch("./data/states.json")
    .then(r => r.json())

  var heatmaps = await fetch("./data/heatmaps.json")
    .then(r => r.json())







  //view

  var mapFunctions = {
    view: {
      saveView: function() {
        log("zoom", name())
        localStorage.setItem('center', JSON.stringify(map.getCenter().toJSON()))
        localStorage.setItem('zoom', map.getZoom())
        // log("zoom",name(), map.getZoom(), JSON.stringify(map.getCenter().toJSON()))
        // log("zoom",name(),)

      },
      loadView: function(map) {
        log("zoom", name())
        var center = localStorage.getItem('center');
        var zoom = localStorage.getItem('zoom');
        if (center || zoom) return

        // log("old",center, zoom);
        map.setCenter(JSON.parse(center));
        map.setZoom(Number(zoom));
      },
    },


    markers: {
      markers: [],
      deselectAll: function() {
        log("old", name());
        return this.markers
          .filter(m => m.deselect)
          .map(m => m.deselectMarkers())
      },
      clearMarkers: function() {
        log("old", name(), map.length)
        this.markers.map(r => r.setMap(null))
        this.markers = []
        this.saveMarkersToMemory()
      },
      deleteMarker: function(marker) {
        this.markers = this.markers.filter(m => m != marker)
        marker.setMap(null)
        this.saveMarkersToMemory()
      },
      loadMarkers: function() {
        log("old", name());
        var data = JSON.parse(localStorage.getItem('geoPoints'));
        // map.data.addGeoJson(data);
        if (data) data.map(marker => this.placeMarker({
          ...marker,
          imported: true
        }))
      },

      saveMarkersToMemory: function() {
        log("old", name());
        localStorage.setItem('geoPoints', JSON.stringify(this.markers
          // .filter(m => m.setEditable)
          .map(m => m.export())))
      },

      placeMarker: function(info) {
        //
        log("old", name());
        //if no position, fuck it
        if (!info.position) return

        // make marker
        var marker = new google.maps.Marker({
          ...info,
          position: info.position,
          map: map,
          data: info.data || {},
          save: () => this.saveMarkersToMemory(),
          export: function() {
            return {
              position: this.position,
              data: this.data,
            }
          },
        });

        log("old", "placing marker at ", info.position.toString());


        if (!marker.data.noInput) {

          //#########  make the inside fo the popup box
          var inputContainer = document.customCreateElement('form', {})
          inputContainer.onsubmit = (e) => {
            !allowEdits && e.preventDefault()
          }
          var textField = document.customCreateElement('input', {
            type: "text",
            size: "31",
            maxlength: "31",
            tabindex: "-1",
            value: marker.data.inputContent + info.position.toString()

          }, inputContainer)
          if (allowEdits) {
            var saveButton = document.customCreateElement('button', {
              innerText: "Submit",
              onclick: (e) => {
                log("old", "Saved marker", marker);
                marker.data.inputContent = textField.value
                marker.save()
                e.preventDefault()
              }
            }, inputContainer)

            var deleteButton = document.customCreateElement('button', {
              innerText: "Delete",
              onclick: (e) => {
                log("old", "Delete marker", marker);
                this.deleteMarker(marker)
                e.preventDefault()
              }
            }, inputContainer)
          }

          // #########
          marker.infowindow = new google.maps.InfoWindow({
            content: inputContainer
          });

          marker.deselect = () => {
            marker.infowindow.close(map, marker)
          }
          marker.select = () => {
            this.deselectAll()
            marker.infowindow.open(map, marker)
          }


          if (!info.imported) marker.select()
          // if (!info.imported) marker.infowindow.open(map, marker)

          if (allowEdits) {
            google.maps.event.addListener(marker, 'click', function() {
              marker.select()
            });
          } else {
            google.maps.event.addListener(marker, 'mouseover', function() {
              marker.select()
            });
          }


        }


        this.markers.push(marker)

        marker.save()
      }

    }
  }


  document.onkeydown = function(evt) {
    if (evt.key === "Escape" || evt.key === "Esc") mapFunctions.markers.deselectAll()
  };









  mapFunctions.markers.loadMarkers(map);
  mapFunctions.view.loadView(map);


  function bindViewListeners(mapLayer) {
    mapLayer.addListener('zoom_changed', mapFunctions.view.saveView);
    mapLayer.addListener('center_changed', mapFunctions.view.saveView);
  }









  function importData(data) {
    for (var [key, value] of Object.entries(data)) {
      log("old", "imported", key);
      localStorage.setItem(key, JSON.stringify(value))
    }
  }


  function makeControl(text, fn, controlDiv, map) {
    // Set CSS for the control border.
    const controlUI = document.createElement("div");
    controlUI.style.backgroundColor = "#fff";
    controlUI.style.border = "2px solid #fff";
    controlUI.style.borderRadius = "3px";
    controlUI.style.boxShadow = "0 2px 6px rgba(0,0,0,.3)";
    controlUI.style.cursor = "pointer";
    controlUI.style.marginBottom = "22px";
    controlUI.style.textAlign = "center";
    controlUI.title = "Click to recenter the map";
    controlDiv.appendChild(controlUI);
    // Set CSS for the control interior.
    const controlText = document.createElement("div");
    controlText.style.color = "rgb(25,25,25)";
    controlText.style.fontFamily = "Roboto,Arial,sans-serif";
    controlText.style.fontSize = "16px";
    controlText.style.lineHeight = "38px";
    controlText.style.paddingLeft = "5px";
    controlText.style.paddingRight = "5px";
    controlText.innerHTML = text;
    controlUI.appendChild(controlText);
    // Setup the click event listeners: simply set the map to Chicago.
    controlUI.addEventListener("click", fn);
  }
  // add buttons
  const centerControlDiv = document.createElement("div");

  map.controls[google.maps.ControlPosition.LEFT].push(centerControlDiv);
  log("old", "ControlPosition", google.maps.ControlPosition)


  //map.data.setControls(['Point']);


  bindViewListeners(map);






  log("old", "loading heatmap");
  var heatmaps = {
    heatmaps: heatmaps,
    activeMaps: [],
    activate: function() {
      Object.keys(this.heatmaps).map(heatmapName => {
        log("old", "making heatmap for", heatmapName);
        var heatmap = new google.maps.visualization.HeatmapLayer({
          data: this.heatmaps[heatmapName].data.map((l, i) =>
            ({
              location: new google.maps.LatLng({
                ...l,
              }),
              weight: l.weight || 1
            })


          ),
          radius: 35,
          // dissipating:false
          gradient: this.heatmaps[heatmapName].gradient
        });
        // if (heatmaps[heatmapName].gradient.length>1) heatmap.set("gradient", heatmaps[heatmapName].gradient);
        // heatmap.set("gradient", heatmaps[heatmapName].gradient);

        heatmap.setMap(map);
        this.activeMaps.push(heatmap)
      })
    }

  }
  log("old", "loading heatmap", "done");






  log("old", "loading states");

  var states = {
    states: states,
    active: [],
    activate: function(specificState) {
      log("old", "acctivating states", this.states);
      Object.entries(this.states).map(stateItem => {
        log("old", "making state for", stateItem[0]);
        const state = new google.maps.Polygon({
          paths: stateItem[1].coords,
          strokeColor: stateItem[1].colour,
          strokeOpacity: 0.8,
          strokeWeight: 2,
          fillColor: stateItem[1].colour,
          fillOpacity: 0.35,
        });

        state.setMap(map);
        this.active.push(state)
      })
    },

  }


  log("old", "loading states", "done");




  var generaticToolsGenerator = {
    init: function() {
      return this
    },
    config: {
      setDraggable: false,
      setEditable: false,
    },
    items: [],
    memory: {
      save: function(data) {
        return localStorage.setItem('geoLines', JSON.stringify(data))
      },
      load: function() {
        var l
        try {
          l = JSON.parse(localStorage.getItem('geoLines'));
        } catch (e) {
          l = []
        }
        return l
      }
    },

    saveItems: function() {
      log("old", "saving lines");
      if (!allowEdits) return
      var tt = this.items.map(l => l.getPath()
        .getArray()
        // .map(p => )
      )
      // log("old",JSON.stringify(tt));
      this.memory.save(tt)
    },
    loadItems: function() {
      var mem = this.memory.load()
      log("old", "loading lines", mem);
      if (!mem) return
      mem.map(linePath => {
        const line = new google.maps.Polyline({
          path: linePath,
        });
        line.setMap(map)
        this.updateLine(line)

        // line .dispatchEvent(e);

      })
    },
    clearItems: function() {
      this.memory.save([])
      this.items.map(l => l.setMap(null))
      this.items = []
    },
    updateLine: function(line) {

      line.setDraggable(this.config.setDraggable)
      line.setEditable(this.config.setEditable)
      line.setOptions({
        strokeColor: 'red',
        strokeOpacity: 0,

        icons: [{
          icon: {
            path: "M 0,-1 0,1",
            strokeOpacity: 1,
            scale: 4,
          },
          offset: "0",
          repeat: "20px",
        }, ]
      });
      this.addDeleteContext(line)
      this.items.push(line)
      this.saveItems()

      var updateEventAction = () => {
        log("old", 'Bounds changed.');
        this.saveItems()
      }


      line.addListener('dragend', updateEventAction)
      line.addListener('dragstart', updateEventAction)
      line.addListener('mouseout', updateEventAction)
      line.addListener('mouseup', updateEventAction)




    },

    addDeleteContext: function(ob) {
      google.maps.event.addListener(ob, "contextmenu", (e) => {
        const deleteMenu = new DeleteMenu();

        // Check if click was on a vertex control point
        if (e.vertex == undefined) {
          return;
        }
        deleteMenu.open(map, ob.getPath(), e.vertex);
        this.saveItems()
      })
    },

    draw: function() {

      const drawingManager = new google.maps.drawing.DrawingManager({
        drawingMode: null,
        drawingControl: true,
        drawingControlOptions: {
          position: google.maps.ControlPosition.TOP_CENTER,
          drawingModes: [
            google.maps.drawing.OverlayType.MARKER,
            // google.maps.drawing.OverlayType.CIRCLE,
            google.maps.drawing.OverlayType.POLYGON,
            google.maps.drawing.OverlayType.POLYLINE,
            google.maps.drawing.OverlayType.RECTANGLE,
          ],
        },
        markerOptions: {
          icon: "https://developers.google.com/maps/documentation/javascript/examples/full/images/beachflag.png",
        },
        circleOptions: {
          fillColor: "#ffff00",
          fillOpacity: 1,
          strokeWeight: 5,
          clickable: false,
          editable: true,
          zIndex: 1,
        },
      });


      drawingManager.setMap(map);



      google.maps.event.addListener(drawingManager, 'markercomplete', (marker) => {
        log("old", marker);
        mapFunctions.markers.placeMarker({
          position: marker.position,
        });
        marker.setMap(null)
      });


      google.maps.event.addListener(drawingManager, 'polylinecomplete', (line) => {
        log("old", "line compelte", line);
        this.updateLine(line)
        const coords = line.getPath().getArray().map(coord => {
          return {
            lat: coord.lat(),
            lng: coord.lng()
          }
        });
      });

      google.maps.event.addListener(drawingManager, 'polygoncomplete', (polygon) => {
        const coords = polygon.getPath().getArray().map(coord => {
          return {
            lat: coord.lat(),
            lng: coord.lng()
          }
        });
        this.addDeleteContext(polygon)
        exportData(coords, 'stateShape')
      });



    }
  }

  var generaticTools = generaticToolsGenerator



  log("old", "loading overlay");
  var overlay = {
    items: {},
    active: [],
    activate: async function() {
      log("old", "acctivating", this.items);




      const imageBounds = {
        north: 6.35895743768598,
        south: -6.05198343189395,
        east: -2.5711641173381707,
        west: 6.35895743768598,
      };
      historicalOverlay = new google.maps.GroundOverlay(
        "/statemap.jpg",
        imageBounds
      );
      historicalOverlay.setMap(map);
      // Object.entries(this.items).map(item => {

      // })
    }
  }
  log("old", "loading overlay", "done");





  // overlay.activate()


  // TEMPLATE
  log("old", "loading fogOfWar");
  var fogOfWar = {

    active: false,
    toggle: function() {
      log("old", "toggling fow, switcching from:", this.active);
      if (!this.active) {
        log("old", "turning on");
        this.shape.setMap(map);

      } else {
        log("old", "turning off");
        this.shape.setMap(null);

      }
      this.active = !this.active

    },
    activate: function() {
      log("old", name());


      const Flatten = require('@flatten-js/core');





      // log("old",name(), map.getBounds(),);
      const {
        polygon
      } = Flatten;
      const {
        unify
      } = Flatten.BooleanOperations;



      var outerbounds = [ // covers the (mercator projection) world
        new google.maps.LatLng(85, 180),
        new google.maps.LatLng(85, 90),
        new google.maps.LatLng(85, 0),
        new google.maps.LatLng(85, -90),
        new google.maps.LatLng(85, -180),
        new google.maps.LatLng(0, -180),
        new google.maps.LatLng(-85, -180),
        new google.maps.LatLng(-85, -90),
        new google.maps.LatLng(-85, 0),
        new google.maps.LatLng(-85, 90),
        new google.maps.LatLng(-85, 180),
        new google.maps.LatLng(0, 180),
        new google.maps.LatLng(85, 180)
      ];


      var mid = (arr) => arr[Math.floor((arr.length - 1) / 2)]
      var allPoints = [
        // mid(mapFunctions.markers.markers.map(m => m.position))
        // ...mapFunctions.markers.markers.map(m => m.position)
        mid(generaticTools.items.map(l => l.getPath().getArray()).flat())
        // generaticTools.items.map(l => l.getPath().getArray()).flat()[0],
        // generaticTools.items.map(l => l.getPath().getArray()).flat()[generaticTools.items.length]
        // ...generaticTools.items.map(l => l.getPath().getArray()).flat()
      ]

      log("old", allPoints);




      var revealRange = 500
      if (allPoints.length < 1) {
        return
      }



      var polyCircles = allPoints.map(pos => drawCircle(pos, revealRange, -1))
        .map(circle => polygon(circle.map(p => [p.lat(), p.lng()])))

      // polyCircles = [
      //   polygon([
      //     [1, 1],
      //     [0, 1],
      //     [0, 0],
      //     [1, 0]
      //   ]),
      //   polygon([
      //     [2, 2],
      //     [0, 2],
      //     [0, 0],
      //   ])
      // ]


      var unifiedShape = polyCircles
        .reduce((accumulator, currentValue) => unify(accumulator, currentValue))
        .vertices.map(p => new google.maps.LatLng(p.x, p.y), )
      log("old", unifiedShape);





      // var circles = allPoints.map(pos => drawCircle(pos, revealRange, -1))

      // Construct the polygon, including both paths.
      this.shape = new google.maps.Polygon({
        // paths: [outerCoords, innerCoords],
        paths: [outerbounds, unifiedShape],
        strokeColor: "gray",
        strokeOpacity: 0.8,
        strokeWeight: 2,
        fillColor: "black",
        fillOpacity: 0.80,
      });
      // this.shape.setMap(map);



      return this



    }
  }
  log("old", "loading fogOfWar", "done");

  /*
  // TEMPLATE
    log("old","loading template");
    var template = {
      items: {},
      active: [],
      activate: function() {
        log("old","acctivating", this.items);

        Object.entries(this.items).map(item => {

        })
      }
    }
    log("old","loading template", "done");

  */


  var setDefaults = async () => {
    log("old", "logging defaultl story ");
    var story = await fetch("./story.json")
      .then(r => r.json())

    return await importData(story)
  }

  var memories = [
    "center",
    "zoom",
    "geoPoints",
    "geoLines",
  ]

  makeControl("Export memory", () => {
    var x = {};
    memories.forEach(v => x[v] = JSON.parse(localStorage.getItem(v)));
    exportData(x);
  }, centerControlDiv, map);

  makeControl("Import memory", async () => runImport(), centerControlDiv, map);


  makeControl("Clear memory", () => {
    memories.forEach(v => localStorage.removeItem(v));
  }, centerControlDiv, map);

  if (allowEdits) {
    makeControl("Clear markers", () => mapFunctions.markers.clearMarkers(), centerControlDiv, map);
    makeControl("Clear lines", () => generaticTools.clearItems(), centerControlDiv, map);
    heatmaps.activate()
    states.activate()

  }





  var tools = generaticTools
  tools.config = {
    setDraggable: allowEdits,
    setEditable: allowEdits,
    // show
  }
  allowEdits && tools.draw();

  var loadStory = async () => {
    await setDefaults()
    rawParams.delete('story')
    rawParams.delete('diag')
    rawParams.append('fow', true)
    window.location = window.location.origin + window.location.pathname + '?' + rawParams.toString()
  }

  if (params.story == "true") {
    loadStory()
  }

  makeControl("Load story mode", async () => loadStory(), centerControlDiv, map);
  makeControl("Load diag mode", async () => {
    rawParams.append("diag", "true")
    rawParams.delete('story')
    window.location = window.location.origin + window.location.pathname + '?' + rawParams.toString()
  }, centerControlDiv, map);




  // setDefaults

  var overlay = document.querySelector('#overlay')


  tools.loadItems()
  //load saved data

  makeControl("Toggle fog of war (experimental)", async () => fog.toggle(), centerControlDiv, map);


  //
  // fog = fogOfWar.activate()
  //
  //
  // if (params.fow == "true") {
  //   fog.toggle()
  // }

  // overlay.style.webkitFilter = `sepia(50%) `


  // ############ get place names ###############




  async function parseLocationNames(fileName) {
    console.log("ok");
    var center = function(arr) {
      var x = arr.map(xy => xy[0]);
      var y = arr.map(xy => xy[1]);
      var cx = (Math.min(...x) + Math.max(...x)) / 2;
      var cy = (Math.min(...y) + Math.max(...y)) / 2;
      return [cx, cy];
    }


    var locations = await fetch(fileName)
      .then(r => r.json())
    // var content = fs.readFileSync(fileName);
    // var locations = JSON.parse(content)
    log("parseLocationNames", locations.length);
    locations = locations.filter((a, i) => i != 0)
    log("parseLocationNames", locations.length);

    var run = location => {
      log("parseLocationNames", location.description);
      log("parseLocationNames", location.boundingPoly);

      // var middle = center(location.boundingPoly.vertices.map(p => [p.x, p.y]))
      var l = location.boundingPoly.vertices[0]
      log("parseLocationNames", l);
      return [l.x, l.y]

    }
    var altdorf = {
      raw: run(locations.find(l => l.description.toLowerCase().includes("altdorf"))),
      map: [31.874268441160677, -16.277407946030955]
    }

    var talabheim = {
      raw: run(locations.find(l => l.description.toLowerCase().includes("talabheim"))),
      map: [35.692076013481106, -0.5703095462174956]
    }





    var undoZero = loc => {
      var offset = [31.874268441160677, -16.277407946030955]
      var offset = [0, -0]
      return [loc[0] + offset[0], loc[1] + offset[1]]
    }



    var findZeroMapLocation = loc => {
      var offset = [-31.874268441160677, 16.277407946030955]
      return [loc[0] + offset[0], loc[1] + offset[1]]
    }


    var findZeroRawLocation = loc => {
      var offset = [-1360, -2434]
      return [loc[0] + offset[0], loc[1] + offset[1]]
    }


    var rawToMapPropOffset = (raw, map) => {
      // var offset = [0.002721174321, 0]
      return [map[0] / raw[0], map[1] / raw[1]]
    }

    var recalculateLocationOfRaw = (raw, offset) => {
      return [raw[0] * offset[0], raw[1] * offset[1]]
    }

    altdorf = {
      ...altdorf,
      findZeroMapLocation: findZeroMapLocation(altdorf.map),
      findZeroRawLocation: findZeroRawLocation(altdorf.raw),
      rawToMapPropOffset: rawToMapPropOffset(altdorf.raw, altdorf.map, )

    }
    altdorf.recalculateLocationOfRaw = recalculateLocationOfRaw(altdorf.raw, altdorf.rawToMapPropOffset)

    talabheim = {
      ...talabheim,
      findZeroMapLocation: findZeroMapLocation(talabheim.map),
      findZeroRawLocation: findZeroRawLocation(talabheim.raw),
      rawToMapPropOffset: rawToMapPropOffset(talabheim.raw, talabheim.map, )

    }
    talabheim.recalculateLocationOfRaw = recalculateLocationOfRaw(talabheim.raw, talabheim.rawToMapPropOffset)





    // 0.002721174321


    log("parseLocationNames", "findZeroMapLocation", "altdorf", altdorf.findZeroMapLocation);
    log("parseLocationNames", "findZeroRawLocation", "altdorf", altdorf.findZeroRawLocation);
    log("parseLocationNames", "rawToMapPropOffset", "altdorf", altdorf.rawToMapPropOffset);
    log("parseLocationNames", "predict", "altdorf", altdorf.recalculateLocationOfRaw);
    // altdorf.recalculateLocationOfRaw






    log("parseLocationNames", "findZeroMapLocation", "talabheim", talabheim.findZeroMapLocation);
    log("parseLocationNames", "findZeroRawLocation", "talabheim", talabheim.findZeroRawLocation);
    log("parseLocationNames", "rawToMapPropOffset", "talabheim", talabheim.rawToMapPropOffset);
    log("parseLocationNames", "predict", "talabheim", talabheim.recalculateLocationOfRaw);
    // talabheim.recalculateLocationOfRaw







    const average = arr => arr.reduce((p, c) => p + c, 0) / arr.length;

    var caluateAverageOffset = (a, b) => {
      return [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2]
    }




    var masterRecalculate = loc => {
      // var offset = [0.018177416262329583, -0.003485554268180884] //master offset
      var offset = [0.012917870435570434, -0.00028359500060541804]

      (50.680797145321655, -29.32968139031974)

      return [loc[0] * offset[0], loc[1] * offset[1]]

    }


    log("parseLocationNames", "masterRecalculate", "altdorf", masterRecalculate(altdorf.raw));

    log("parseLocationNames", "masterRecalculate", "talabheim", masterRecalculate(talabheim.raw));

    mapFunctions.markers.clearMarkers()


    mapFunctions.markers.placeMarker({
      position: new google.maps.LatLng(...masterRecalculate(altdorf.raw))
    })

    mapFunctions.markers.placeMarker({
      position: new google.maps.LatLng(...masterRecalculate(talabheim.raw))
    })



    log("parseLocationNames", "average offset", "both", caluateAverageOffset(altdorf.rawToMapPropOffset, talabheim.rawToMapPropOffset));




    mapFunctions.markers.placeMarker({
      data: {
        inputContent: "Nuln"
      },
      position: new google.maps.LatLng(...masterRecalculate(run(locations.find(l => l.description.toLowerCase().includes("Nuln".toLowerCase())))))
    })
    mapFunctions.markers.placeMarker({
      data: {
        inputContent: "Helmgart"
      },
      position: new google.maps.LatLng(...masterRecalculate(run(locations.find(l => l.description.toLowerCase().includes("Helmgart".toLowerCase())))))
    })





  }


  parseLocationNames('./map/mapreader/foundImages_5120_empire_bw3.json')


  // ############ get place names ###############



}


// log("old","loaded", "customCreateElement")
document.__proto__.customCreateElement = (tag = 'div', attributes = {}, parent) => {
  // // log("old","customCreateElement", tag, attributes)
  var myNewElement = document.createElement(tag);
  for (var a in attributes) {
    if (myNewElement[a] == '' || typeof attributes[a] == 'function') {
      myNewElement[a] = attributes[a]
    } else {
      myNewElement.setAttribute(a, attributes[a]);

    }
  }
  if (parent) parent.appendChild(myNewElement)
  return myNewElement;
}
// params



// add the google key
document.customCreateElement('script', {
  src: `https://maps.googleapis.com/maps/api/js?key=${"AIzaSyAyXFcMs8AssuSNDtU9rUV0S5v4JSMTzDA"}&callback=initMap&libraries=visualization,drawing&v=weekly`,
  defer: true,
  async: true,
}, document.querySelector('head'))
